@import: context
@import: config
@import: link

type align =
  | Start
  | End
  | Center
  | SpaceBetween
  | SpaceEvenly

module ShinchokuTairikuCmd : sig

  direct \emph : [inline-text] inline-cmd
  direct \url : [string] inline-cmd
  direct \minipage : [float; block-text] inline-cmd
  direct \code : [string] inline-cmd
  direct \line-break : [] inline-cmd
  direct \ref : [label] inline-cmd
  direct +p : [inline-text] block-cmd
  direct +row : [align?; inline-text list] block-cmd
  direct +column : [inline-text; block-text] block-cmd
  direct +theorem : [inline-text?; label?; inline-text] block-cmd
  direct +proof : [inline-text?; block-text] block-cmd

end = struct

  let-inline ctx \emph it =
    let ctx = Context.set-font Config.font-cjk-gothic ctx in
    read-inline ctx it

  let-inline ctx \url url =
    let ctx = Context.set-latin-font Config.font-mono ctx in
    read-inline ctx {\href(url)(embed-string url);}

  let-inline ctx \code code =
    let pads = (4pt, 4pt, 4pt, 4pt) in
    let decoset = HDecoSet.rectangle-round-fill 2pt 2pt (Color.gray 0.95) in
    let ctx = Context.set-latin-font Config.font-mono ctx in
    let ib =
      embed-string code
      |> read-inline ctx
      |> inline-frame-breakable pads decoset
    in
    script-guard Latin ib

  let-inline ctx \minipage ratio inner =
    let width = get-text-width ctx *' ratio in
    embed-block-top ctx width (fun ctx -> read-block ctx inner)

  let-inline ctx \line-break =
    discretionary (0 - 10000) inline-nil inline-fil inline-nil

  let-inline ctx \ref label =
    get-cross-reference (label ^ `:num`)
    |> Option.from `?`
    |> embed-string
    |> read-inline ctx
    |> Link.to label

  let-block ctx +p it =
    let ib = inline-skip 10pt ++ read-inline ctx it ++ inline-fil in
    form-paragraph ctx ib

  let inline-join start endd delim ibs =
    let-rec f l =
      match l with
      | [] -> inline-nil
      | [x] -> x
      | x :: xs -> x ++ delim ++ f xs
    in
    start ++ f ibs ++ endd

  let-block ctx +row ?:alignopt its =
    let align = Option.from SpaceEvenly alignopt in
    let ibs = List.map (read-inline ctx) its in
    let ib =
      match align with
      | Start -> inline-join inline-nil inline-fil inline-nil ibs
      | End -> inline-join inline-fil inline-nil inline-nil ibs
      | Center -> inline-join inline-fil inline-fil inline-nil ibs
      | SpaceBetween -> inline-join inline-nil inline-nil inline-fil ibs
      | SpaceEvenly -> inline-join inline-fil inline-fil inline-fil ibs
    in
    line-break true true ctx ib

  let-block ctx +column title inner =
    let make-title ctx =
      let ctx =
        ctx
        |> Context.set-font Config.font-cjk-gothic-bold
        |> set-font-size Config.font-size-large
        |> set-paragraph-margin 10pt 10pt
      in
      read-inline ctx {コラム:} ++ inline-skip 3pt ++ read-inline ctx title
      |> line-break true false ctx
    in
    let make-inner ctx =
      let ctx = set-paragraph-margin Config.paragraph-margin-top Config.paragraph-margin-bottom ctx in
      read-block ctx inner
    in
    let decoset = VDecoSet.simple-frame-stroke 1pt (Color.gray 0.5) in
    let pads = (8pt, 8pt, 8pt, 8pt) in
    let ctx-outer = set-paragraph-margin 20pt 20pt ctx in
    block-frame-breakable ctx-outer pads decoset
      (fun ctx -> make-title ctx +++ make-inner ctx)

  % +theorem and +proof are copied from stdjareport.satyh

  let-mutable num-theorems <- 0

  let theorem-scheme ctx ctxf category wordopt label inner =
    let () = increment num-theorems in
    let s-num =
      (arabic (!num-theorems))
    in
    let () = register-cross-reference (label ^ `:num`) s-num in
    let it-num = embed-string s-num in
    let ib-dfn =
      read-inline (ctx |> Context.set-latin-font Config.font-latin-bold) {#category; #it-num;}
    in
    let ib-word =
      match wordopt with
      | None       -> inline-nil
      | Some(word) -> read-inline ctx {\ (#word;).}
    in
    let ib-inner = read-inline (ctxf ctx) inner in
    line-break true true ctx
      (ib-dfn ++ ib-word ++ inline-skip (get-font-size ctx) ++ ib-inner ++ inline-fil)

  let-block ctx +theorem ?:wordopt ?:labelopt inner =
    let label = Label.or-fresh (Option.map (fun l -> `theorem:` ^ l) labelopt) in
    theorem-scheme ctx (Context.set-latin-font Config.font-latin-italic) {Theorem} wordopt label inner

  let-block ctx +proof ?:wordopt inner =
    let ib-heading =
      let ctx = ctx |> Context.set-latin-font Config.font-latin-italic in
        match wordopt with
        | None    -> read-inline ctx {Proof.}
        | Some(w) -> read-inline ctx {Proof of #w;.}
    in
    let ib-box = read-inline ctx {▪} in
    line-break true false ctx ib-heading
      +++ read-block ctx inner
      +++ line-break false true ctx (inline-fil ++ ib-box)

end
